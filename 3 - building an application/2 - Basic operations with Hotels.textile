h1. Basic resource operations

This chapter will introduce how to use the basic HTTP verbs to create, remove and retrieve a resource or a resource collection.
This use of the HTTP verbs has been widely adopted although with a few modifications from the HTTP specification due to some PUT
restrictions.

h2. Creating hotels

There are two HTTP verbs that allows us to create resources on the server side.
In order to create hotels we will use the most famous solution: sending a POST request to /city.
First we need to receive the POST data and transform it into our domain data. Once the client defined the mime-type and the server configured which classes represents each media types, it can easily be achieved as:

[server code]
rails hotel-system
cd hotel-system
script/generate scaffold hotel name:string city:string room_count:integer
rake db:create:all
rake db:migrate
[/server code]

We then configure restfulie at **enviroment.rb**:

[code]
config.gem "restfulie", :version => ">= 0.5.0"
[/code]

And configure **development.rb** to ignore its sequential protection feature:

[code]
config.action_controller.allow_forgery_protection    = false
[/code]

[section Configuring the model]

[server example]
class Hotel < ActiveRecord
	acts_as_restfulie
	media_type "vnd/hotel+xml", "vnd/hotel+json"
end
[/server example]

The 1-1 mapping between our domain model and resources might not be the best solution, and we will see later how to map resources in other ways to our domain.

If the result was a success, the POST method should return the resource location and a 201 Created response, allowing the client to retrieve the resource data if required.

[server example]
location= url_for resource
render_resource resource, options, {:status => :created, :location => location}
[/server example]

This code will generate a response 201 with the resource location in the "Location" header.

The entire code for the server controller would check if the save process was successful and react accordingly: rendering the error messages if something failed.

[TODO check unprocessable entity is a valid response? and its body?]

[server example]
class HotelsController < ApplicationController::Base
	def create
	    @hotel = Restfulie.from request
	    if @hotel.save
	      render_created @city
	    else
	      render :xml => @city.errors, :status => :unprocessable_entity
	    end
	end
end
[/server example]

If the server wants to avoid one extra request-response trip, it can return the resource content with the XXX return code and the client will not need another request to retrieve this information.

Note that render_created will already do it for us, returning a response as:

[box]
There is one major validation step missing in the code above: the object created invoking *Restfulie.from* might not be a hotel and we are not checking its content-type. In order to check it if the request media-type matches the expected one:

[code]
	valid = Restfulie::MediaType.supports?(request.headers['CONTENT_TYPE']) &&
        	Restfulie::MediaType.media_type(request.headers['CONTENT_TYPE']) == Hotel
[/code]
[/box]

[section Default behaviour]

As creating through POST, saving it to the database and responding with a 201 is the typical behaviour for REST systems.

Once your controller includes the RestController module, there is no need to define the create method unless you want to change its behaviour:

[server example]
class HotelsController < ApplicationController
  include Restfulie::Server::RestController

	# implicit declarated the create method
	# including media-type checking

end
[/server example]

[client example]
hotel = {:name => "Caelum Objects Hotel", :city => "Sao Paulo", :room_count => 3}

hotel = Restfulie.at('http://localhost:3000/hotels').as('vnd/caelum_hotel+xml').create(hotel.to_xml(:root => "hotel"))

puts "Response was #{hotel.web_response}"
[/client example]

[section Accessing headers and the response itself]

Sometimes the clients want to access the http response information itself and you can do it with Restfulie through the web_response method which is the Net::HTTPResponse object itself:

[client example]
hotel = Restfulie.at('http://localhost:30000/hotels/1').get
puts "Hotel created at #{hotel.web_response['Content-type']}"
[/client example]

[box]
You can remove both new and create methods from your HotelsController as they are not needed.
[/box]










[section Evolving the server]

The previous example demonstrates how our client code can be written detached from the resource model or server side model: there was no need to create a Hotel representation on the client side end to
make things work.

What would happen if the server wants to evolve its model with new fields?

[code]
script/generate migration add_hotel_rate
[/code]

And enter the new *rate* field

[code]
class AddHotelRate < ActiveRecord::Migration
  def self.up
    add_column :hotels, :rate, :integer
    Hotel.all.each do |h|
      h.rate = 3
      h.save
    end
  end

  def self.down
    remove_column :hotels, :rate
  end
end
[/code]

Finally, run your database migration:

[code]
rake db:migrate
[/code]

Clients which are unaware of that new information available in the resource still work.
Meanwhile, new or modified clients can make use of that available information:

[code]
hotel = {:name => "Caelum Objects Hotel", :city => "Sao Paulo", :room_count => 3, :rate => 4}
hotel = Restfulie.at('http://localhost:3000/hotels').as('vnd/caelum_hotel+xml').create(hotel.to_xml(:root => "hotel"))
puts "Rated: #{hotel.rate}"
[/code]

[box important]
The server side can evolve its model without affecting running clients. REST client frameworks
should be written in a way that allows servers to evolve its model content without affecting the client.
This behaviour is called forward-compatibility and is implemented in Restfulie through the use of dynamic generated methods that allow access to the new unexpected content.
[/box important]








[section Mapping responses to our domain]

In most cases we want to map resource access responses to our domain models, so in our case we want to create a class
which represents a Hotel in the client side:

[code]
class Hotel < ActiveRecord::Base
	uses_restfulie
end
[/code]

And now we can read it from a specific URI:

[code]
hotel = Hotel.from_web 'http://localhost:3000/hotels/1'
puts "Hotel #{hotel.name} retrieved"
[/code]

[TODO section error retrieval]

[section Content type]

- Most of the web request [need reference] is based on data retrieval correctly using the GET verb.
- Content type negotiation: if the existing resource can be represented in that media-type, gives it
- Restfulie knows how to transform to xml and json by default
- Otherwise, complain


[section Retrieving a list of resources]

The entry point to an application can be a list of available resources of an specific type.
In our hotel book management system, the entry point will be a choice of available hotels.

In the server side, one can render the list of hotels as a resource:

[code]
def index
  @hotels = Hotel.all
  render_resource @hotels
end
[/code]

And a request to this URI accepting xml as its return will give back a list of hotels:

[code]
GET /hotels
Accept: application/xml
[/code]
[code]
<?xml version="1.0" encoding="UTF-8"?>
<hotels>
  <hotel>
    <city>Sao Paulo</city>
    <created-at>2009-12-13T22:44:09Z</created-at>
    <id>1</id>
    <name>Caelum Objects Hotel</name>
    <rate>4</rate>
    <room-count>3</room-count>
    <updated-at>2009-12-13T22:44:09Z</updated-at>
  </hotel>
  <hotel>
    <city>Sao Paulo</city>
    <created-at>2009-12-13T22:44:21Z</created-at>
    <id>2</id>
    <name>Some Other Hotel</name>
    <rate>4</rate>
    <room-count>3</room-count>
    <updated-at>2009-12-13T22:44:21Z</updated-at>
  </hotel>
</hotels>
[code]

The <b>render_resource</b> method will handle content type negotiation but by creating a resource which reflects state from other resources - the hotels themselves - we loose some visibility: a change to the second hotel will also affect the list resource.

[note anyways a delete will always affect the list, how bad is it really?]

Another approach to creating a list of resources is to let hypermedia drive our client application and represent the list of resources as connected resources to this collection.

Typical formats that allow representations with hypermedia support are application/xhtml with our own microformat:

[note note that in xhtml with a table and content, there is still the duplication issue... otherwise the table is just dumb!]

[code]
<?xml version="1.0" encoding="UTF-8"?>
<html>
<body>
	<table class="hotels">
		<tr id="1">
			<td>Sao Paulo</td>
    <td>2009-12-13T22:44:09Z</created-at>
    <td>Caelum Objects Hotel</name>
    <td>4</td>
    <td>3</td>
    <td>2009-12-13T22:44:09Z</td>
  </hotel>
  <hotel>
    <city>Sao Paulo</city>
    <created-at>2009-12-13T22:44:21Z</created-at>
    <id>2</id>
    <name>Some Other Hotel</name>
    <rate>4</rate>
    <room-count>3</room-count>
    <updated-at>2009-12-13T22:44:21Z</updated-at>
  </hotel>
</hotels>
[/code]

[section Retrieve as an atom feed]

- works in the same way

[code]
	server side code to generate the above mentioned code
[/code]


[section Create cities]


[section Updating cities]

[section Updating hotels]

[section Removing hotels]


[section Creating flight routes]

[section Server side resource <-> code mapping]

[section Client side resource <-> domain mapping]
