h1. Basic resource operations

This chapter will introduce how to use the basic HTTP verbs to create, remove and retrieve a resource or a collection.
This use of the HTTP verbs has been widely adopted although with a few modifications from the HTTP specification due to some PUT
restrictions.

Rails provides support for CRUD over HTTP verbs using request parameters instead of resource representations therefore Restfulie will allow the use of the later to deal with resources.

h2. Our hotel media-type

We start creating our hotel model with three fields describing it, its name, city and total number of rooms, using Rail's scaffold feature, that also generates our controller:

<pre>
script/generate scaffold hotel name:string city:string room_count:integer
rake db:create:all
rake db:migrate
</pre>

Our hotel representation can not be pure xml as it is not a hypermedia format. We will adopt a custom media-type that
provides information for our hotel and supports links: **vnd/hotel+xml**.

We configure Restfulie to use this media type for our Hotel by invoking the **media_type** method:

<pre>
class Hotel < ActiveRecord
	acts_as_restfulie
	media_type "vnd/hotel+xml"
end
</pre>

A valid representation of our hotel is:

<pre>
<hotel>
	<name>Caelum Objects Hotel</name>
	<room_count>220</roomt_count>
	<city>Sao Paulo</city>
</hotel>
</pre>

The 1-1 mapping between our domain model and resources might not be the best solution, and we will see later how to map resources in other ways to our domain.

h2. Creating hotels

Once the client defined the mime-type and the server configured which classes represents each media types, we can focus on acting with our resources.

There are two HTTP verbs that allows us to create resources on the server side. In order to create hotels we will use the most widely used solution: sending a **post** request to /hotels.

First we need to receive the **post** data (the resource representation) and transform it into our domain data. 

If the result was a success, the **post** method should return the resource location and a **201 Created** response, allowing the client to retrieve the resource data if required.

<pre>
location = url_for resource
render_resource resource, options, {:status => :created, :location => location}
</pre>

This code will generate a response 201 with the resource location in the **Location** header.

The controller still needs to check if the process was successfully completed or not and, if something goes wrong, render the related error messages.

<blockquote>TODO check unprocessable entity is a valid response? and its body?</blockquote>

<pre>
class HotelsController < ApplicationController::Base
	def create
	    @hotel = Restfulie.from request
	    if @hotel.save
	      render_created @city
	    else
	      render :xml => @city.errors, :status => :unprocessable_entity
	    end
	end
end
</pre>

<blockquote>TODO image with both paths: everything ok, something wrong, show representation on image</blockquote>

If the server wants to avoid one extra request-response trip, it can return the resource content with the XXX return code and the client will not need another request to retrieve this information.

Note that render_created will already do it for us, returning a response as:

<blockquote>
There is one major validation step missing in the code above: the object created invoking *Restfulie.from* might not be a hotel and we are not checking its content-type. In order to check if the media-type sent matches the expected one:

<pre>
valid = Restfulie::MediaType.supports?(request.headers['CONTENT_TYPE']) &&
       	Restfulie::MediaType.media_type(request.headers['CONTENT_TYPE']) == Hotel
</pre>
</blockquote>

h2. Default behaviour

The typical behaviour for CRUD systems following REST is to create resources through **post** by translating the resource to domain models, saving them to the database and responding with a 201.

When using Restfulie, those common cases are supported by default if your controller includes the **RestController** module, which includes the behaviour displayed so far:

<pre>
class HotelsController < ApplicationController
  include Restfulie::Server::RestController

	# implicit declarated the create method
	# including media-type checking

end
</pre>

<blockquote>TODO describe client, move client code up?</blockquote>

<pre>
hotel = {:name => "Caelum Objects Hotel", :city => "Sao Paulo", :room_count => 3}

hotel = Restfulie.at('http://localhost:3000/hotels').as('vnd/caelum_hotel+xml').create(hotel.to_xml(:root => "hotel"))

puts "Response was #{hotel.web_response}"
</pre>

h2. Accessing headers and the response itself

Sometimes the clients want to access the http response information itself and you can do it with Restfulie through the web_response method which is the Net::HTTPResponse object itself:

<pre>
hotel = Restfulie.at('http://localhost:30000/hotels/1').get
puts "Hotel created at #{hotel.web_response['Content-type']}"
</pre>

<blockquote>
You can remove both new and create methods from your HotelsController as they are not needed.
</blockquote>










h2. Evolving the server

The previous example demonstrates how our client code can be written detached from the resource model or server side model: there was no need to create a Hotel representation on the client side end to
make things work.

What would happen if the server wants to evolve its model with new fields?

<pre>
script/generate migration add_hotel_rate
</pre>

And enter the new *rate* field

<pre>
class AddHotelRate < ActiveRecord::Migration
  def self.up
    add_column :hotels, :rate, :integer
    Hotel.all.each do |h|
      h.rate = 3
      h.save
    end
  end

  def self.down
    remove_column :hotels, :rate
  end
end
</pre>

Finally, run your database migration:

<pre>
rake db:migrate
</pre>

Clients which are unaware of that new information available in the resource still work.
Meanwhile, new or modified clients can make use of that available information:

<pre>
hotel = {:name => "Caelum Objects Hotel", :city => "Sao Paulo", :room_count => 3, :rate => 4}
hotel = Restfulie.at('http://localhost:3000/hotels').as('vnd/caelum_hotel+xml').create(hotel.to_xml(:root => "hotel"))
puts "Rated: #{hotel.rate}"
</pre>

<blockquote>
The server side can evolve its model without affecting running clients. REST client frameworks
should be written in a way that allows servers to evolve its model content without affecting the client.
This behaviour is called forward-compatibility and is implemented in Restfulie through the use of dynamic generated methods that allow access to the new unexpected content.
</blockquote>








h2. Mapping responses to our domain

In most cases we want to map resource access responses to our domain models, so in our case we want to create a class
which represents a Hotel in the client side:

<pre>
class Hotel < ActiveRecord::Base
	uses_restfulie
end
</pre>

And now we can read it from a specific URI:

<pre>
hotel = Hotel.from_web 'http://localhost:3000/hotels/1'
puts "Hotel #{hotel.name} retrieved"
</pre>


h2. Content type

<blockquote>
TODO
- Most of the web request [need reference] is based on data retrieval correctly using the GET verb.
- Content type negotiation: if the existing resource can be represented in that media-type, gives it
- Restfulie knows how to transform to xml and json by default
- Otherwise, complain
</blockquote>
















h2. Retrieving a list of resources

Either the entry point to an application can be a list of available resources of an specific type or at some point our client ends up retrieving a list of resources.
In our hotel book management system, the entry point will be a choice of available hotels, so in the server side, one can render the list of hotels as a resource:

<pre>
def index
  @hotels = Hotel.all
  render_resource @hotels
end
</pre>

And a request to this URI accepting xml as its return content-type will give back a list of hotels:

<pre>
GET /hotels
Accept: application/xml
</pre>

<pre>
<?xml version="1.0" encoding="UTF-8"?>
<hotels>
  <hotel>
    <city>Sao Paulo</city>
    <created-at>2009-12-13T22:44:09Z</created-at>
    <id>1</id>
    <name>Caelum Objects Hotel</name>
    <rate>4</rate>
    <room-count>3</room-count>
    <updated-at>2009-12-13T22:44:09Z</updated-at>
  </hotel>
  <hotel>
    <city>Sao Paulo</city>
    <created-at>2009-12-13T22:44:21Z</created-at>
    <id>2</id>
    <name>Some Other Hotel</name>
    <rate>4</rate>
    <room-count>3</room-count>
    <updated-at>2009-12-13T22:44:21Z</updated-at>
  </hotel>
</hotels>
</pre>

Although the *render_resource* method handled content negotiation and generated valid *application/xml* content, in order to add extra behaviour or flow control to the list of hotels we are required to create a new media type, one that encapsulates many instances of hotels.

By following this path of new a media type creation for every different type of information retrieval, the project will end up with a high number of custom media types, making them useless for other systems and losing the ability to be understood by a larger number of clients.





h2. Free caching and 304 support
















h2. The hotel list Atom feed

If we create an atom feed for our hotels, we are able to use a well-known and standard media type that other clients are already capable of understanding.

An Atom feed representing the same response mentioned earlier would be:

<pre>
<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
	<id>http://localhost:3000/hotels</id>
	<title type="text">Hotels</title>
	<updated>2009-12-21T00:22:24-08:00</updated>
	<author><name>Hotels</name></author>
	<link rel="self" href="http://localhost:3000/hotels"/>
	 <entry>
    <id>http://localhost:3000/hotels/1</id>
     <title type="text">Hotel</title>
     <updated>2009-12-13T22:44:09-08:00</updated>
     <link rel="self" href="http://localhost:3000/hotels/1"/>
     <content type="vnd/caelum_hotel+xml">
       <hotel>
			<city>Sao Paulo</city>
			<created-at>2009-12-13T22:44:09Z</created-at>
			<id>1</id>
			<name>Caelum Objects Hotel</name>
			<rate>4</rate>
			<room-count>3</room-count>
			<updated-at>2009-12-13T22:44:09Z</updated-at>
		</hotel>
     </content>
   </entry>
   <entry>
     <id>http://localhost:3000/hotels/2</id>
     <title type="text">Hotel</title>
     <updated>2009-12-13T22:44:21-08:00</updated>
     <link rel="self" href="http://localhost:3000/hotels/2"/>
     <content type="vnd/caelum_hotel+xml">
			<hotel>
				<city>Sao Paulo</city>
				<created-at>2009-12-13T22:44:21Z</created-at>
				<id>2</id>
				<name>Caelum Objects Hotel</name>
				<rate>4</rate>
				<room-count>3</room-count>
				<updated-at>2009-12-13T22:44:21Z</updated-at>
			</hotel>
     </content>
   </entry>
</feed>
</pre>

And in order to generate such atom feed, we simply need to define its title:

<pre>
  def index
    @hotels = Hotel.all
    render :text => @hotels.to_atom(:title=>'Hotels', :controller => self), :content_type => 'application/atom+xml'
  end
</pre>

Again, the default inherited *index* method behaves returning an atom feed if one access the 'http://localhost:3000/hotels' URI: if there is no need for customization, there is less code to be written.

h2. Hypermedia in our resource list

Another approach to creating a list of resources is to let hypermedia drive our client application and represent the list of resources as connections that can be accessed through their own URIs.

Typical formats that allow representations with hypermedia support are application/xhtml with our own microformat:

<blockquote>TODO add links here</blockquote>

<pre>
<?xml version="1.0" encoding="UTF-8"?>
<html>
<body>
	<table class="hotels">
		<tr id="1">
			<td>Sao Paulo</td>
	    <td>2009-12-13T22:44:09Z</td>
	    <td>Caelum Objects Hotel</td>
	    <td>4</td>
	    <td>3</td>
	    <td>2009-12-13T22:44:09Z</td>
			<td>http://localhost:3000/hotels/1</td>
	  </tr>
	  <tr>
	    <td>Sao Paulo</td>
	    <td>2009-12-13T22:44:21Z</td>
	    <td>2</td>
	    <td>Some Other Hotel</td>
	    <td>4</td>
	    <td>3</td>
	    <td>2009-12-13T22:44:21Z</td>
			<td>http://localhost:3000/hotels/1</td>
	  </tr>
	</table>
</body>
</html>
</pre>

With such representation, one can retrieve the actual resource and act with it after accessing its URI. In the client side,
the code will resemble navigating through connected resources:

<pre>
	hotels = Restfulie.at(HOTELS_ENTRY_POINT).get
	hotel = hotels[1].
	???????????? code which navigates????????
</pre>

h2. Atom feed and partial resource representation

In our atom feed representation, Restfulie inserts by default the link to every resource. If you want partial rendering for each resource, it can be achieved by customizing the *to_xml* invocation:

<pre>
def index
  @hotels = Hotel.all
  render :text => @hotels.to_atom(:title=>'Hotels', :controller => self), :content_type => 'application/atom+xml' do |hotel|
		hotel.to_xml(:skip_instruction => true, :only => :name)
	end
end
</pre>

In this case, our atom feed will look like:

<pre>
	<?xml version="1.0"?>
	      <feed xmlns="http://www.w3.org/2005/Atom">
	        <id>http://localhost:3000/hotels</id>
	        <title type="text">Hotels</title>
	        <updated>2009-12-21T00:22:24-08:00</updated>
	        <author><name>Hotels</name></author>
	        <link rel="self" href="http://localhost:3000/hotels"/>
	          <entry>
	            <id>http://localhost:3000/hotels/1</id>
	            <title type="text">Hotel</title>
	            <updated>2009-12-13T22:44:09-08:00</updated>
	            <link rel="self" href="http://localhost:3000/hotels/1"/>
	            <content type="vnd/caelum_hotel+xml">
	              <hotel>
	  				<name>Caelum Objects Hotel</name>
					</hotel>
	            </content>
	          </entry>
	          <entry>
	            <id>http://localhost:3000/hotels/2</id>
	            <title type="text">Hotel</title>
	            <updated>2009-12-13T22:44:21-08:00</updated>
	            <link rel="self" href="http://localhost:3000/hotels/2"/>
	            <content type="vnd/caelum_hotel+xml">
	              <hotel>
	  					<name>Caelum Objects Hotel</name>
					</hotel>
	            </content>
	          </entry>
	</feed>
</pre>

h2. Segmentation by freshness

Sometimes a resource is composed by a list of other resources as our hotel list example. Another one is an human entry point containing four sections: the top 10, my bookings, random items, and special deals.

In this case, all information come from the same source, but every part has a different probable validity if it is going to be cached. If the page is served as one big chunck of information, it will always be stale due to the random items section. "My orders" is stale only when I place a new order and, in the same way, the top 10 is only stale if any item is bought and surpasses the number of times the 10th item was bought so far.

One of the main issues with this type of pages which aggregate information from one or many sources with <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.21">different expire-expectations</a> is that cached versions in proxies and clients become stale faster than it should for some elements: once one of this providing sources publishes new information or is updated, the entire representation becomes stale..

<a href="http://www.martinfowler.com/bliki/SegmentationByFreshness.html">Martin Fowler described</a> a well spread approach to allow those pages to be partially cached within local proxies and clients, thus sharing requested representations between multiple users.

Given the hotel scenario, we could create different resources:

<ul>
<li>http://caelumhotels.com/top_sellers</li>
<li>http://caelumhotels.com/myself/bookings</li>
<li>http://caelumhotels.com/random</li>
<li>http://caelumhotels.com/special</li>
</ul>

<blockquote>myself/bookings should be my username itself due to caching capabilities for intermediate layers</blockquote>

And finally an aggregating page:

<pre>
&lt;html&gt;
&lt;a class="lazy_load" href="http://caelumhotels.com/top_sellers"&gt;Top sellers&lt;/a&gt;
&lt;a class="lazy_load" href="http://caelumhotels.com/myself/bookings"&gt;My bookings&lt;/a&gt;
&lt;a class="lazy_load" href="http://caelumhotels.com/random"&gt;Random items&lt;/a&gt;
&lt;a class="lazy_load" href="http://caelumhotels.com/special"&gt;Special items&lt;/a&gt;

</pre>

And then, for each <b>lazy_load</b> link, we create a <b>div</b> with its content:

<pre>
&lt;script&gt;
$('.lazy_load').each(function(link) {
  uri = link.attr('href'); 
  div = $('<div></div>').load(uri); // cache hits!
  link.after(div);
});
&lt;/script&gt;
&lt;/html&gt;
</pre>

This allows our proxies to cache each component in our page apart from the page itself: whenever its content becomes stale in a proxy, only part of that page needs to be updated.

In a web were most data can be cached and does not become stale so fast, this technique should usually lessen the amount of data being transfered between client and server.

All one needs to do is <a href="http://www.mnot.net/cache_docs/">properly use the http headers for caching</a>.

<blockquote>Remember that if your client supports either parallel requests to the server and/or keep-alive connection, the results might be even better.</blockquote>

Pretty much in the same way as with the human web, a distributed system using the web as its infrastructure will <a href="http://www.mnot.net/cache_docs/">gain the same cache benefits </a>as long as they implement correct caching policies through http headers (and correct http verbs).

When your server provides a resource representation linking to a series of other related resources the client and proxies staying on the way will be allowed to cache each and every other resource on its own.

This approach results in changes applied to one resource not affecting cached representations of other resources. An stale representation will not affect those accessing other resources within the same context.

Sometimes the decision whether to change latency for scalability might depend on how you think your clients will use your resources: in the human web mentioned above, the developer knew exactly how its clients would access it.

<blockquote>Remember: there is zero latency for unexpired resources and there is small latency for retrieving cached versions of a resource from a shared proxy</blockquote>

<blockquote>TODO image shared proxy: show the advantage</blockquote>

In distributed systems using REST, guessing how resources will be used can be dangerous as it allows you to tight couple yourself to this behaviour while published resources can and would be used in unforeseen ways.

Giving information that will help most cases is fine and providing links to further resources details allow you to balance between latency and scalability - due to caching - as you wish.

h3. Dynamic contracts

This is only possible because we have <a href="http://guilhermesilveira.wordpress.com/2009/12/08/hypermedia-making-it-easier-to-create-dynamic-contracts/">signed dynamic contracts with our clients.</a> They expect us to follow some formal format definition (<a href="http://www.w3.org/TR/xhtml1/">defined in xhtml</a>) and processes. How our processes are presented within our representations is the dynamic part of the contract.

While the fixed part can be validated<a href="http://www.w3.org/XML/Schema"> with the use of schema validators</a>, the dynamic part - the process - which is guided by our server needs to be validated through testing the behaviour of our applications: asserting that hypermedia guided transitions should be reflected in our application state.

h2. Progressive enhancement

Martin notes that this is a <a href="http://en.wikipedia.org/wiki/Progressive_enhancement">kind of progressive enhancement</a>: although its definition is related to accessibility, its control over bandwidth benefits are similar to the approach mentioned ones.

h2. Updating hotels

h2. Removing hotels

h2. Create flight routes

Now we will replicate the hotel creation and feed features with flight routes, which will be much faster because we already know how to configure Restfulie on the server side.


[section Server side resource <-> code mapping]

[section Client side resource <-> domain mapping]


<blockquote>Good Relations RDF at http://booking.cheaptotravel.com/hotel/10017444-10210890O.html</blockquote>
