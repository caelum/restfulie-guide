<h1>The travel agency system</h1>

Throughout the book, we will be a web system that allow clients to book hotels and flights using a RESTful API, implying in a set of constraints which the architecture has to follow in order to obtain the advantages mentioned by Roy Fielding in his dissertation [reference Roy's dissertation].

<h2>The first client</h2>

Our system is composed by two different client APIs, one allows ourselves to register hotels and browse through them.

A simple entry point that provides us a list of hotels can add to its representation hints that guide the client within the processes built on the server, in our case the process of registering a new hotel:

<pre>
<hotels>
	<link rel="http://caelumobjects.com/hotels/add" href="http://localhost:3000/hotels" />
	<hotel>
		<name>Caelum Sao Paulo</name>
	</hotel>
	<hotel>
		<name>Caelum Rio de Janeiro</name>
	</hotel>
	<hotel>
		<name>Caelum London</name>
	</hotel>
</hotels>
</pre>
 
On the client side, after requesting the representation for all hotels, one can access the add hotel relationship through Restfulie's API:

<pre>
hotels = Restfulie.at(HOTELS_ENTRY).get
puts "There are currently #{hotels.length} hotels"
hotels.add new_hotel
</pre>

Due to the use of hypermedia within the content representation, the POST request sent when invoking <i>hotels.add</i> is enough to create the new resource in the URI provided by the server.

h2. Searching

Following the same idea of hypermedia guiding the client, a search system could be implemented through a set of link relations, first locating hotels in 'Sao Paulo', then showing only those with 4 starts and finally sorting by price, each one represented by a hypermedia link being followed.

<pre>
hotels = Restfulie.at(HOTELS_ENTRY).get
hotel = hotels.at('Sao Paulo').rated(4).sort_by(:price).first
</pre>

Another approach is to access generic searches as those which implement the OpenSearch protocol [reference opensearch], one can register query parameters prior to executing the query. Assuming that the hotels representation provides us enough information to identify the OpenSearch definition document:

<pre>
<hotels>
	<link rel="http://caelumobjects.com/hotels/search" href="http://localhost:3000/hotels/open_search" />
	<link rel="http://caelumobjects.com/hotels/add" href="http://localhost:3000/hotels" />
	<hotel>
		<name>Caelum Sao Paulo</name>
	</hotel>
	<hotel>
		<name>Caelum Rio de Janeiro</name>
	</hotel>
	<hotel>
		<name>Caelum London</name>
	</hotel>
</hotels>
</pre>

Restfulie allows access to such document and open search through method invocations on the client side:

<pre>
hotels = Restfulie.at(HOTELS_ENTRY).get
hotel = hotels.search.at('Sao Paulo').rated(4).sort_by(:price).first
</pre>

h2. The advanced client

Unfortunately that will not be enough for the second set of clients, that want to book both hotels and flights together:

<pre>
hotels = Restfulie.at(HOTELS_ENTRY).get
hotel = hotels.at('Sao Paulo').rated(4).sort_by(:price).first
flight = hotel.city.to('London').at(December.05.2010).first
booking = Restfulie.at(BOOKING_ENTRY).post
booking.hotels.add hotel
booking.flights.add flight
confirmation = booking.pay payment
</pre>

This code is a much richer and powerful example as it uses hypermedia to guide the client through a more complex process, finally finding the requested information as in <i>hotels.at('Sao Paulo').rated(4).sort_by(:price).first</i>

Later, there is an atomic execution which involves more than one request:
<pre>
	booking.hotels.add hotel
	booking.flights.add flight
	confirmation = booking.pay payment
</pre>

All those examples can run after our system is built.